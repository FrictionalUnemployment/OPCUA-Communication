# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'zuo.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets, Qt
from PyQt5.QtWidgets import QMenu
from zeroconf import ServiceBrowser, Zeroconf
import server_discovery as dsc
import client_nodes as cl_node
from opcua import client, Client
from client_nodes import StandardItem as StItem
import navigating_nodes as nav
import sys


class Node_storage:  # Necessary for keeping track of every standarditem and where it belongs too and information that is good for references.
    def __init__(self, server_name, node_name, node_id, standarditem):
        self.server_name = server_name
        self.node_name = node_name
        self.node_id = node_id
        self.standarditem = standarditem


# Used for when an user subscribes to a node and wants information from it (Middle widget)
class Subscription_storage:
    def __init__(self, server_name, node_name, node_id, server_address, row, tablewidget):
        self.server_name = server_name
        self.node_name = node_name
        self.node_id = node_id
        # Keep track of what row to append the information into.
        self.row = row
        self.server_address = server_address
        self.tableWidget = tablewidget

        self.tableWidget.setItem(self.row, 0, QtWidgets.QTableWidgetItem(
            self.server_name))  # Set the server name and append into the widget
        self.tableWidget.setItem(self.row, 1, QtWidgets.QTableWidgetItem(
            self.node_name))  # Set node name into the widget

        # Node_id converted to string and appended.
        self.tableWidget.setItem(
            self.row, 2, QtWidgets.QTableWidgetItem(str(self.node_id)))

        self.client = Client("opc.tcp://" + self.server_address)

        self.client.connect()
        # Get the data values from the node we are subscribing to
        var = self.client.get_node(node_id)
        # DataValue(Value:Variant(val:19,type:VariantType.Int64), StatusCode:StatusCode(Good), SourceTimestamp:2021-03-13 12:36:58.621994)
        # Example of outprint from var

        # Create a subscription handelr to update the variables value outprint. Also send in the widget and row
        handler = SubHandler(self.row, self.tableWidget)
        sub = self.client.create_subscription(
            500, handler)  # Refresh every 500 ms
        handle = sub.subscribe_data_change(var)  # Send in the variable object.


class SubHandler(object):
    def __init__(self, row, tablewidget):
        self.row = row  # Keep track of the row to know where to append
        # Get the tablewidget as this is a class it requires it.
        self.tableWidget = tablewidget

    """
    Subscription Handler. To receive events from server for a subscription
    data_change and event methods are called directly from receiving thread.
    Do not do expensive, slow or network operation there. Create another
    thread if you need to do such a thing
    """

    def datachange_notification(self, node, val, data):
        # print("Python: New data change event", node, val)
        # When a data change happens we append the value to the widget.
        self.tableWidget.setItem(
            self.row, 3, QtWidgets.QTableWidgetItem(str(val)))
        self.tableWidget.setItem(self.row, 4, QtWidgets.QTableWidgetItem(
            str(data.monitored_item.Value.Value.VariantType)))  # Get the variant type of the node
        self.tableWidget.setItem(self.row, 5, QtWidgets.QTableWidgetItem(
            str(data.monitored_item.Value.SourceTimestamp)))  # Get the time stamp and display
        self.tableWidget.setItem(self.row, 6, QtWidgets.QTableWidgetItem(
            str(data.monitored_item.Value.StatusCode)))  # Get the statuscode Good, Bad
        # We update the tableWidget, so that the update becomes present in the user client.
        self.tableWidget.viewport().update()


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        self.clients = list()
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1014, 513)
        MainWindow.setStyleSheet("background-color: rgb(200, 200, 200;")
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        self.Connect = QtWidgets.QPushButton(self.centralwidget)
        self.Connect.setGeometry(QtCore.QRect(780, 0, 81, 21))
        self.Connect.setStyleSheet("color: rgb(0, 0, 0);")
        self.Connect.clicked.connect(self.manual_connection)
        self.Connect.setObjectName("Connect")

        self.Discover = QtWidgets.QPushButton(self.centralwidget)
        self.Discover.setGeometry(QtCore.QRect(690, 0, 81, 21))
        self.Discover.setStyleSheet("color: rgb(0, 0, 0);")
        self.Discover.clicked.connect(self.discover_servers)
        self.Discover.setObjectName("Discover")

        self.lineEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit.setGeometry(QtCore.QRect(10, 0, 681, 21))
        self.lineEdit.setStyleSheet("color: rgb(0, 0, 0);")
        self.lineEdit.setObjectName("lineEdit")

        self.tableWidget = QtWidgets.QTableWidget(self.centralwidget)
        self.tableWidget.setGeometry(QtCore.QRect(340, 26, 612, 325))
        self.tableWidget.setStyleSheet("color: rgb(0, 0, 0);")
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(7)
        self.tableWidget.setRowCount(0)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(3, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(4, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(5, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(6, item)

        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)
        self.textBrowser.setGeometry(QtCore.QRect(10, 360, 942, 111))
        self.textBrowser.setObjectName("textBrowser")

        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(870, 0, 81, 21))
        self.pushButton.setStyleSheet("color: rgb(0, 0, 0);")
        self.pushButton.setObjectName("pushButton")

        self.pairingbutton = QtWidgets.QPushButton(self.centralwidget)
        self.pairingbutton.setGeometry(QtCore.QRect(960, 0, 81, 21))
        self.pairingbutton.setStyleSheet("color: rgb(0, 0, 0);")
        self.pairingbutton.setObjectName("pairButton")
        self.pairingbutton.hide()
        self.pairingbutton.clicked.connect(self.linking_servers)

        self.treeView = QtWidgets.QTreeView(self.centralwidget)
        self.treeView.setGeometry(QtCore.QRect(10, 26, 331, 325))
        self.treeView.setObjectName("treeView")
        self.treeView.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.treeView.customContextMenuRequested.connect(self.contextMenuEvent)

        self.right_treeView = QtWidgets.QTreeView(self.centralwidget)
        self.right_treeView.setGeometry(QtCore.QRect(951, 26, 331, 325))
        self.right_treeView.setObjectName("Right_treeview")
        self.right_treeView.hide()

        self.Connect.raise_()
        self.Discover.raise_()
        self.lineEdit.raise_()
        self.textBrowser.raise_()
        self.pushButton.raise_()
        self.treeView.raise_()
        self.tableWidget.raise_()
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 912, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 914, 21))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        self.menuView = QtWidgets.QMenu(self.menubar)
        self.menuView.setObjectName("menuView")
        MainWindow.setMenuBar(self.menubar)
        self.closing_app = QtWidgets.QAction(MainWindow)
        self.closing_app.setObjectName("Closing Application")
        self.closing_app.setShortcut("CTRL+Q")
        self.closing_app.triggered.connect(self.closing_application)
        self.actionRight_Hand_tree = QtWidgets.QAction(MainWindow)
        self.actionRight_Hand_tree.setObjectName("actionRight_Hand_tree")
        self.actionRight_Hand_tree.setShortcut("CTRL+N")
        self.actionRight_Hand_tree.triggered.connect(
            self.creating_right_window)
        self.hide_Right_Hand_tree = QtWidgets.QAction(MainWindow)
        self.hide_Right_Hand_tree.setObjectName("Hiding tree")
        self.hide_Right_Hand_tree.setShortcut("CTRL+M")
        self.hide_Right_Hand_tree.triggered.connect(self.closing_right_window)

        self.menuFile.addAction(self.closing_app)
        self.menuView.addAction(self.actionRight_Hand_tree)
        self.menuView.addAction(self.hide_Right_Hand_tree)

        self.menubar.addAction(self.menuFile.menuAction())
        self.menubar.addAction(self.menuView.menuAction())

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        ############################### Discovery ################################

        self.treeModel = Qt.QStandardItemModel()
        self.treeView.setHeaderHidden(True)
        self.rootNode = self.treeModel.invisibleRootItem()
        self.treeView.setModel(self.treeModel)
        self.treeView.doubleClicked.connect(self.getValueLeft)
        ###### Right hand tree #######
        self.right_treeView.setModel(self.treeModel)
        self.right_treeView.doubleClicked.connect(self.getValueLeft)

        ## VARIABLES #####
        self.ROOT_CHILDREN_NODES = []

        ## TABLE WIDGET - MIDDLE PART - #####
        self.row = 0
        self.subscriptions_array = list()

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "CustomOPC"))
        self.Connect.setText(_translate("MainWindow", "Connect"))
        self.Discover.setText(_translate("MainWindow", "Discover"))
        item = self.tableWidget.horizontalHeaderItem(0)
        item.setText(_translate("MainWindow", "Server name"))
        item = self.tableWidget.horizontalHeaderItem(1)
        item.setText(_translate("MainWindow", "Node Name"))
        item = self.tableWidget.horizontalHeaderItem(2)
        item.setText(_translate("MainWindow", "Node Id"))
        item = self.tableWidget.horizontalHeaderItem(3)
        item.setText(_translate("MainWindow", "Value"))
        item = self.tableWidget.horizontalHeaderItem(4)
        item.setText(_translate("MainWindow", "DataType"))
        item = self.tableWidget.horizontalHeaderItem(5)
        item.setText(_translate("MainWindow", "TimeStamp"))
        item = self.tableWidget.horizontalHeaderItem(6)
        item.setText(_translate("MainWindow", "Quality"))

        self.textBrowser.setHtml(_translate("MainWindow", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
                                            "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
                                            "p, li { white-space: pre-wrap; }\n"
                                            "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:8.25pt; font-weight:400; font-style:normal;\">\n"
                                            "<p style=\"-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-size:8pt;\"><br /></p></body></html>"))
        self.pushButton.setText(_translate("MainWindow", "Disconnect"))
        self.pairingbutton.setText(_translate("MainWindow", "Pair"))

        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.menuView.setTitle(_translate("MainWindow", "View"))
        self.actionRight_Hand_tree.setText(_translate(
            "MainWindow", "Expand a right hand tree"))
        self.hide_Right_Hand_tree.setText(_translate(
            "MainWindow", "Hide the right hand tree"))
        self.closing_app.setText(_translate("MainWindow", "Quit"))

    def onitemclicked(self):
        item = self.treeView.currentIndex()
        print(item.text(0))

    def closing_application(self):
        QtWidgets.qApp.quit()

    # Linking the servers and navigating all the nodes and finding the correct qx ix subscription.
    def linking_servers(self):
        server1 = None
        server2 = None
        nav1 = None
        nav2 = None
        for i in self.clients:
            if(i.ROOT_NODE.checkState() == 2 and server1 == None):
                server1 = i
                i.client.connect()
                n = nav.Navigating_nodes(i.client)
                nav1 = n.get_children_nodes_name(n.get_root_nodes())
                i.client.disconnect()
                self.textBrowser.append("Linked server 1: " + i.server_name)
            if(i.ROOT_NODE.checkState() == 2 and i.server_name != server1.server_name):
                server2 = i
                i.client.connect()
                n = nav.Navigating_nodes(i.client)
                nav2 = n.get_children_nodes_name(n.get_root_nodes())
                i.client.disconnect()
                self.textBrowser.append("Linked server 2: " + i.server_name)

        if(server2 != None and server1 != None):
            for dict1_key, dict1_values in nav1.items():
                for value in dict1_values:
                    for key2, values2 in nav2.items():
                        for value2 in values2:
                            if value[2:] == value2[2:]:

                                if 'ix' in value and 'qx' in value2:
                                    server1.client.connect()
                                    get_obj = server1.client.get_objects_node().get_children()
                                    for i in get_obj:
                                        function_name = server1.client.get_node(
                                            i).get_display_name()._text
                                        print(function_name)
                                        if('Methods' == function_name):
                                            bl = server1.client.get_node(i).call_method(
                                                "2:subscribe", "opc.tcp://" + server2.Server, str(dict1_key), str(key2))
                                            self.textBrowser.append(bl)
                                    server1.client.disconnect()
                                if 'qx' in value and 'ix' in value2:
                                    server2.client.connect()
                                    get_obj = server2.client.get_objects_node().get_children()
                                    for i in get_obj:
                                        function_name = server2.client.get_node(
                                            i).get_display_name()._text

                                        if('Methods' == function_name):
                                            bl = server2.client.get_node(i).call_method(
                                                "2:subscribe", "opc.tcp://" + server1.Server, str(key2), str(dict1_key))
                                            self.textBrowser.append(bl)
                                    server2.client.disconnect()

        # server1.client.connect()
        # f = server1.client.get_objects_node().get_children()
        # for i in f:
        #    kkk = server1.client.get_node(i).get_display_name().__dict__['_text']
       #     print(server1.client.get_node(i).get_display_name()._text)

    def getValueLeft(self, val):
        node_name = val.data()
        bool_continue = True
        root = val.parent()  # The root node of the node index that the user double clicks

        # We loop till we get None as data (We're at the end of the hierarchy)
        while(root.parent().data() != None):
            root = root.parent()

        for i in self.clients:  # Loop through our servers and make sure it already isn't in the treeview
            if(i.server_name == node_name):
                for k in i.NODE_ID:
                    i.client.connect()
                    for j in self.ROOT_CHILDREN_NODES:
                        if(i.server_name == j.server_name):
                            children_name = i.client.get_node(
                                k).get_browse_name().__dict__['Name']
                            if(children_name == j.node_name):
                                bool_continue = False
                                break
                    i.client.disconnect()

        for i in self.clients:  # Loop through our servers and make sure it already isn't in the treeview
            if(root.data() == i.server_name):
                for j in self.ROOT_CHILDREN_NODES:
                    if(node_name == j.node_name and root.data() == j.server_name):
                        i.client.connect()
                        for d in i.client.get_node(j.node_id).get_children():
                            children_name = i.client.get_node(
                                d).get_browse_name().__dict__['Name']
                            for k in self.ROOT_CHILDREN_NODES:
                                if(children_name == k.node_name and root.data() == k.server_name):
                                    self.textBrowser.append(
                                        "Children_name already exists! " + children_name + " " + k.node_name)
                                    bool_continue = False
                                    break
                        i.client.disconnect()

        for i in self.clients:  # We add the first children to the root node
            if(i.server_name == node_name and bool_continue == True):

                for j in i.NODE_ID:

                    i.client.connect()
                    children_name = i.client.get_node(
                        j).get_browse_name().__dict__['Name']
                    qtitem = StItem(children_name, 8,
                                    color=QtGui.QColor(180, 180, 180))
                    i.ROOT_NODE.appendRow(qtitem)
                    server_name = node_name
                    self.ROOT_CHILDREN_NODES.append(Node_storage(
                        server_name, children_name, j, qtitem))
                    i.client.disconnect()

        # We add the first children to the first children of the root node (and etc)
        for i in self.clients:
            if(root.data() == i.server_name):

                for j in self.ROOT_CHILDREN_NODES:
                    if(node_name == j.node_name and root.data() == j.server_name and bool_continue == True):

                        i.client.connect()
                        for d in i.client.get_node(j.node_id).get_children():
                            children_name = i.client.get_node(
                                d).get_browse_name().__dict__['Name']
                            qtitem = StItem(children_name, 8,
                                            color=QtGui.QColor(180, 180, 180))
                            j.standarditem.appendRow(qtitem)
                            server_name = root.data()
                            self.ROOT_CHILDREN_NODES.append(Node_storage(
                                server_name, children_name, d, qtitem))
                        i.client.disconnect()

    def creating_right_window(self):
        # resizing the window to be able to fit the new treeview
        MainWindow.resize(1300, 513)
        # making the textbox bigger to be able to display more information
        self.textBrowser.resize(1272, 111)
        self.right_treeView.show()
        self.pairingbutton.show()

    def closing_right_window(self):
        self.right_treeView.hide()
        self.textBrowser.resize(942, 111)
        self.pairingbutton.hide()

    # Manually create a connection to a server and append it to the arrays for navigation.
    def manual_connection(self):
        adress = self.lineEdit.text()
        self.clients.append(cl_node.Client_nodes(adress, adress))
        self.rootNode.appendRow(self.clients[-1].ROOT_NODE)
        self.textBrowser.append("Manually added service: " +
                                adress + " !Note: name will be set to the address:port!")

    def discover_servers(self): # For discovering and displaying the OPC UA servers in the UA interface.
        if len(self.clients) > 0: # We check if clients have been added and remove them if so to not create duplicate clients.
            self.clients.clear()
            self.treeModel.removeRows(0, self.treeModel.rowCount())

        # We also remove the children nodes.
        if len(self.ROOT_CHILDREN_NODES) > 0:
            self.ROOT_CHILDREN_NODES.clear()

        # We create an instance of Server_discovery.
        url=dsc.Server_Discovery()
        # We call the get servers function to get the servers.
        url.get_servers()
        # We get the server names (in a list) from the servers and store it.
        self.SERVER_ARR=url.get_all(0)
        # We get a list of the addresses and port ex : [192.168.1.10:3249, 192.168.1.5:3249]
        servers=url.get_all_as_address()
        print(servers)

        j=0
        for i in servers:  # We iterate through the server list
            # We append a Client_nodes instance into an array for further reference.
            self.clients.append(cl_node.Client_nodes(i, self.SERVER_ARR[j]))
                                                                             # Client_nodes arguments require the IP:PORT and server name which it stores.
            self.textBrowser.append(
                "Service added: " + self.SERVER_ARR[j] + "- At address: " + i)  # Logger for the User interface.

            # We iterate through all servers but we also need to add the correct server_name which is also an array. Best to just use a counter here.
            j += 1

        for i in self.clients:  # We add the server name to the treeview.
            self.rootNode.appendRow(i.ROOT_NODE)
        #print()

    def contextMenuEvent(self, pos):
        indexes = self.treeView.indexAt(pos)
        print(indexes.data())

        root = indexes.parent()  # The root node of the node index that the user double clicks

        # We loop till we get None as data (We're at the beginning of the hierarchy)
        while(root.parent().data() != None):
            root = root.parent()

        menu = QMenu()
        # Note that it creates a button to any widget. Fail-safes have not been added.
        subscribe = menu.addAction("Subscribe to variable")

        # Display the action at correct position.
        action = menu.exec_(self.treeView.viewport().mapToGlobal(pos))

        # We add another count to the tablewidget.
        self.tableWidget.setRowCount(self.row + 1)

        server_address = None
        nodes_id_and_name = None
        node_id = None

        # If someone presses the button then we want to iterate and find that variable and display it.
        if(action == subscribe):

            # Find the right client and if the server_name is equals to the first treeview node (The root node) then continue
            for i in self.clients:
                if(i.server_name == root.data()):
                    # Add the server to our local variable.
                    server_address = i.Server
                    # Connect to the UA client for the UA server.
                    i.client.connect()
                    n = nav.Navigating_nodes(i.client)
                    nodes_id_and_name = n.get_children_nodes_name(
                        n.get_root_nodes())  # Lets recursively get all the nodes and its name : id
                    i.client.disconnect()  # Disconnect from the UA client after we're done
                    break

            # Let us find the node id for the variable name that we're trying to subscribe to
            for dict1_key, dict1_values in nodes_id_and_name.items():
                for value in dict1_values:
                    # indexes.data tells us what variable we are trying to subscribe to.
                    if(value == indexes.data()):
                        # Lets set the local node id variable to the actual variables node id.
                        node_id = dict1_key
                        # dict1_key is the node id and dict1_values is the string name of the node.

            self.subscriptions_array.append(Subscription_storage(
                root.data(), indexes.data(), node_id, server_address, self.row, self.tableWidget))  # We also store all the information (For future reference) also to create our subscription handler.
            # As we have subscribed to a variable, next subscription needs to be on the next row.
            self.row += 1
        self.textBrowser.append("Created a subscription to: " + str(indexes.data()))
     

    

# Set up the User Interface window.
if __name__ == "__main__": 

    app=QtWidgets.QApplication(sys.argv)
    MainWindow=QtWidgets.QMainWindow()
    ui=Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()

    sys.exit(app.exec_())
